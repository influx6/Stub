//simple class system

var Stub=(function(){
    
    var mixer = function(client,server){
	for(var e in server){
	    client[e] = server[e];
	}
    };

    var class_methods = {

	inherit: function(parent){
		if(typeof parent !== "function"  && typeof parent !== "object"){
			throw new Error("argument given is not an object or function!");
		}
		
		if(!this.prototype._super){
	    		var pro = parent.prototype;
	    		var self = this.prototype;
	    		self._super = pro;
	    
	    		for(var e in pro){
				if(!self[e]){    
		    		self[e] = pro[e];
				}
	    		}
	    	return true; 
	    }
	    
	    return false;
	},
	
	extend: function(ability){
	    if(typeof ability !== 'object'){
		throw new Error('Argument passed is not an Object!');
	    }
	    var self = this;
	    for(var e in ability){
		    self[e] = ability[e];
	    }
	    return;
	},
	
	include: function(ability){
	    if(typeof ability !== 'object'){
		throw new Error('Argument passed is not an Object!');
	    }
	    var self = this.prototype;
	    for(var e in ability){
		    self[e] = ability[e];
	    }
	    return;
	},

    };

    var proto_methods = {
	
	map: function(obj,callback){
	    var result = [],self=this;
	    
	    if(!obj.each){
		self.onEach(obj,function(o,b){
		    result.push(callback.call(this,o));
		});
		return result;
	    }else{
	        obj.each(function(){
		     result.push(callback.call(this,o));
		});
		return result;
	    }
	},

	each: function(callback){
	    var self = this;
	    for(var e in self){
		callback.call(self,e,self);
	    }
	},
	
	onEach: function(obj,callback){

	    if(this.isObjectType(obj,'array') || this.isObjectType(obj,'string')){
		for(var i=0; i < obj.length; i++){
		    callback.call(this,obj[i],obj,i);
		}
		return;
	    }

	    if(this.isObjectType(obj,'object')){
		for(var e in obj){
		    callback.call(this,e,obj);
		}
		return;
	    }
	},

	objectType: function(){
	    var self = this;
	    return ({}).toString.call(self).match(/\s([\w]+)/)[1].toLowerCase();
	},

	isObjectType: function(obj,type){
	    return ({}).toString.call(obj).match(/\s([\w]+)/)[1].toLowerCase() === type.toLowerCase();
	},

	has: function(method,obj){
	    if(!method || typeof method != 'string'){
		throw new Error("Argument being passed is not a string!");
	    }
	    var status=false;
	    
	    this.each(function(n,obj){
		if(method === n){
		    status = true;
		    console.log(method,":",typeof obj[method]);
		}
	    });
	    return status;
	},

	bindEvent: function(){},
	
	unbindEvent: function(){},

	triggerEvent: function(){},

	flushEvents: function(){},
	
	proxy: function(){}
    };

    return {
    
    	map: proto_methods.map,
    	isObjectType: proto_methods.isObjectType,
	onEach: proto_methods.onEach,
	
	create: function(ability){
	    
	    function Stub(){
	    	this.eventList=[];
		if(this._super){
		    this._super.constructor.call(this);
		}
		if(this.initialize){
		    this.initialize.apply(this,arguments);
		}
	    };
	    
	    mixer(Stub,class_methods);
	    mixer(Stub.prototype,proto_methods);

	    Stub.prototype.constructor = Stub;
	    Stub.fn = Stub.prototype;
	    Stub.fn.initialize = function(){};
	    
	    if(ability){
		if(ability['extend']){ Stub.extend(ability.extend) };
		if(ability['include']){ Stub.include(ability.include) };
		if(!ability['extend'] && !ability['include']){ Stub.include(ability) };
	    }
	
	    return Stub;
	}
    };
})();
